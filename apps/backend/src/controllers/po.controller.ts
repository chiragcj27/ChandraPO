import { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import { File, PO } from '@repo/db';
import { s3Service } from '../services/s3.service';
import { fastapiService } from '../services/fastapi.service';
import type {
  ExtractedLine,
  ExtractedPOResponse,
  FileMetadata,
  PODocumentShape,
  POItemRecord,
  PurchaseOrderDTO,
  PurchaseOrderItemDTO,
} from '../types/po';

const normalizeDate = (value?: string | Date | null) => {
  if (!value) return undefined;
  const date = typeof value === 'string' ? new Date(value) : value;
  if (Number.isNaN(date.getTime())) return undefined;
  return date;
};

const formatDateForClient = (value?: Date | string | null) => {
  if (!value) return undefined;
  const date = typeof value === 'string' ? new Date(value) : value;
  if (Number.isNaN(date.getTime())) return undefined;
  return date.toISOString().split('T')[0];
};

const mapRecordToDTO = (record: POItemRecord): PurchaseOrderItemDTO => ({
  IsIncomplete: record.isIncomplete ?? false,
  ClientItemCode: record.clientItemCode ?? '',
  ChandraItemCode: record.chandraItemCode ?? '',
  JobBagNumber: record.jobBagNumber ?? '',
  Description: record.description ?? '',
  Quantity: record.quantity ?? 0,
  MetalType: record.metalType ?? '',
  MetalColor: record.metalColor ?? '',
  Category: record.category ?? '',
  Remarks: record.remarks ?? '',
  Size: record.size ?? undefined,
  size: record.size ?? undefined,
  StampingInstructions: record.stampingInstructions ?? '',
  StampRequired: record.stampRequired ?? false,
  DeadlineDate: formatDateForClient(record.deadlineDate ?? null) ?? null,
  ShippingDate: formatDateForClient(record.shippingDate ?? null) ?? null,
  InvoiceNumber: record.invoiceNumber ?? '',
});

const mapDTOToRecord = (item: PurchaseOrderItemDTO): POItemRecord => ({
  isIncomplete: Boolean(item.IsIncomplete),
  clientItemCode: item.ClientItemCode || '',
  chandraItemCode: item.ChandraItemCode || '',
  jobBagNumber: item.JobBagNumber || '',
  description: item.Description || '',
  quantity: Number(item.Quantity) || 0,
  metalType: item.MetalType || '',
  metalColor: item.MetalColor || '',
  category: item.Category || '',
  remarks: item.Remarks || '',
  size: item.Size || item.size || undefined,
  stampingInstructions: item.StampingInstructions || '',
  stampRequired: Boolean(item.StampRequired),
  deadlineDate: normalizeDate(item.DeadlineDate ?? undefined) ?? null,
  shippingDate: normalizeDate(item.ShippingDate ?? undefined) ?? null,
  invoiceNumber: item.InvoiceNumber || '',
});

const mapDocToDTO = (po: PODocumentShape): PurchaseOrderDTO => ({
  PONumber: po.poNumber,
  PODate: formatDateForClient(po.poDate) || '',
  ClientName: po.clientName,
  TotalItems: po.totalItems,
  IncompleteItems: po.incompleteItems,
  TotalValue: po.totalValue,
  Status: po.status,
  AutoGeneratedContent: po.autoGeneratedContent?.map(mapRecordToDTO) ?? [],
  Items: po.items?.map(mapRecordToDTO) ?? [],
  PO: po.poFiles?.map((file) => file.path) ?? [],
  Invoices: po.invoices ?? [],
  ClientReminderCount: po.clientReminderCount ?? 0,
});

const mapDTOToDoc = (dto: PurchaseOrderDTO): Partial<PODocumentShape> => {
  const items = dto.Items?.map(mapDTOToRecord) ?? [];
  const autoGenerated = dto.AutoGeneratedContent?.map(mapDTOToRecord) ?? items;

  return {
    poNumber: dto.PONumber,
    poDate: normalizeDate(dto.PODate) ?? new Date(),
    clientName: dto.ClientName,
    totalItems: dto.TotalItems ?? items.length,
    incompleteItems: dto.IncompleteItems ?? items.filter((item) => item.isIncomplete).length,
    totalValue: dto.TotalValue ?? 0,
    status: dto.Status || 'New',
    autoGeneratedContent: autoGenerated,
    items,
    invoices: dto.Invoices ?? [],
    clientReminderCount: dto.ClientReminderCount ?? 0,
  };
};

const mapExtractionLineToRecord = (line: ExtractedLine, invoiceNumber?: string): POItemRecord => ({
  isIncomplete: false,
  clientItemCode: line.StyleCode || line.ItemRefNo || line.ItemPoNo || 'UNKNOWN',
  chandraItemCode: line.ItemRefNo || '',
  jobBagNumber: line.ItemPoNo || '',
  description:
    line.CustomerProductionInstruction ||
    line.DesignProductionInstruction ||
    line.SpecialRemarks ||
    line.StyleCode ||
    '',
  quantity: Number(line.OrderQty) || 0,
  metalType: line.Metal || '',
  metalColor: line.Tone || '',
  category: line.Category || '',
  remarks: line.SpecialRemarks || '',
  size: line.ItemSize !== undefined && line.ItemSize !== null ? String(line.ItemSize) : undefined,
  stampingInstructions: line.StampInstruction || '',
  stampRequired: Boolean(line.StampInstruction),
  deadlineDate: null,
  shippingDate: null,
  invoiceNumber: invoiceNumber || '',
});

const buildPOFromExtraction = (extraction: ExtractedPOResponse, fileMeta: FileMetadata): PODocumentShape => {
  const items = (extraction.lines || []).map((line) => mapExtractionLineToRecord(line, extraction.invoice_number));
  const poNumber = extraction.invoice_number?.trim() || generatePoNumberFromFilename(fileMeta.filename);
  const poDate = extraction.invoice_date ? normalizeDate(extraction.invoice_date) ?? new Date() : new Date();

  return {
    poNumber,
    poDate: poDate || new Date(),
    clientName: extraction.client_name || 'Unknown Client',
    totalItems: items.length,
    incompleteItems: items.filter((item) => item.isIncomplete).length,
    totalValue: Number(extraction.total_value) || 0,
    status: 'New',
    autoGeneratedContent: items,
    items,
    poFiles: [fileMeta],
    invoices: extraction.invoice_number ? [extraction.invoice_number] : [],
    clientReminderCount: 0,
  };
};

const generatePoNumberFromFilename = (filename: string) => {
  const timestamp = Date.now();
  const sanitized = filename.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9-_]/g, '-');
  return `${sanitized || 'PO'}-${timestamp}`;
};

const upsertFileMetadata = async (meta: FileMetadata) => {
  const savedFile = await File.create(meta);
  return {
    key: savedFile.key,
    path: savedFile.path,
    filename: savedFile.filename,
    createdAt: savedFile.createdAt,
    updatedAt: savedFile.updatedAt,
  };
};

export const getPOs = async (_req: Request, res: Response) => {
  try {
    const pos = await PO.find().sort({ poDate: -1 });
    const response = pos.map((poDoc: any) => mapDocToDTO(poDoc.toObject() as PODocumentShape));
    res.status(200).json(response);
  } catch (error) {
    console.error('Error fetching POs:', error);
    res.status(500).json({ message: 'Failed to fetch POs' });
  }
};

export const getPOByNumber = async (req: Request, res: Response) => {
  try {
    const po = await PO.findOne({ poNumber: req.params.poNumber });
    if (!po) {
      return res.status(404).json({ message: 'PO not found' });
    }
    res.status(200).json(mapDocToDTO(po.toObject() as PODocumentShape));
  } catch (error) {
    console.error('Error fetching PO:', error);
    res.status(500).json({ message: 'Failed to fetch PO' });
  }
};

export const updatePO = async (req: Request, res: Response) => {
  try {
    const dto = req.body as PurchaseOrderDTO;
    if (dto?.PONumber && dto.PONumber !== req.params.poNumber) {
      return res.status(400).json({ message: 'PO number mismatch' });
    }
    const update = mapDTOToDoc(dto);
    const po = await PO.findOneAndUpdate({ poNumber: req.params.poNumber }, update, { new: true });
    if (!po) {
      return res.status(404).json({ message: 'PO not found' });
    }
    res.status(200).json(mapDocToDTO(po.toObject() as PODocumentShape));
  } catch (error) {
    console.error('Error updating PO:', error);
    res.status(500).json({ message: 'Failed to update PO' });
  }
};

export const uploadPO = async (req: Request, res: Response) => {
  try {
    const file = req.file as Express.Multer.File | undefined;
    if (!file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const uploadResult = await s3Service.uploadFile(file.buffer, file.originalname, file.mimetype, 'pos');
    const fileMeta = await upsertFileMetadata({
      key: uploadResult.key,
      path: uploadResult.url,
      filename: file.originalname,
    });

    const extraction = await fastapiService.extractPurchaseOrder(file);
    const poPayload = buildPOFromExtraction(extraction, fileMeta);

    let existing = await PO.findOne({ poNumber: poPayload.poNumber });

    if (existing) {
      const fileAlreadyLinked = existing.poFiles?.some(
        (entry: FileMetadata) => entry.key === fileMeta.key,
      );
      if (!fileAlreadyLinked) {
        existing.poFiles = [...(existing.poFiles || []), fileMeta];
      }

      existing.poDate = poPayload.poDate;
      existing.clientName = poPayload.clientName;
      existing.totalItems = poPayload.totalItems;
      existing.incompleteItems = poPayload.incompleteItems;
      existing.totalValue = poPayload.totalValue;
      existing.status = 'New';
      existing.autoGeneratedContent = poPayload.autoGeneratedContent;
      existing.items = poPayload.items;
      existing.invoices = Array.from(new Set([...(existing.invoices || []), ...poPayload.invoices]));
      existing.clientReminderCount = existing.clientReminderCount ?? 0;

      await existing.save();
    } else {
      existing = await PO.create(poPayload);
    }

    res.status(201).json({
      message: 'PO uploaded and processed successfully',
      po: mapDocToDTO(existing.toObject() as PODocumentShape),
    });
  } catch (error) {
    console.error('Error in uploadPO:', error);
    res.status(500).json({ message: 'Failed to upload PO', error: (error as Error).message });
  }
};

const resolveLegacyFilePath = (filePath: string) => {
  if (filePath.startsWith('uploads/')) {
    return path.resolve(process.cwd(), 'apps/api', filePath);
  }
  if (path.isAbsolute(filePath)) {
    return filePath;
  }
  return path.resolve(process.cwd(), filePath);
};

export const streamPOPdf = async (req: Request, res: Response) => {
  try {
    const fileParam = (req.query.file as string) || '';
    if (!fileParam) {
      return res.status(400).json({ message: 'File parameter is required' });
    }

    const po = await PO.findOne({ poNumber: req.params.poNumber });
    if (!po) {
      return res.status(404).json({ message: 'PO not found' });
    }

    const matchingFile =
      po.poFiles?.find(
        (file: FileMetadata) => file.path === fileParam || file.key === fileParam,
      ) ?? null;
    const targetPath = matchingFile?.path || matchingFile?.key || fileParam;

    if (/^https?:\/\//i.test(targetPath)) {
      return res.redirect(targetPath);
    }

    const absolutePath = resolveLegacyFilePath(targetPath);
    if (!fs.existsSync(absolutePath)) {
      return res.status(404).json({ message: 'PDF file not found' });
    }

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `inline; filename="${path.basename(absolutePath)}"`);
    fs.createReadStream(absolutePath).pipe(res);
  } catch (error) {
    console.error('Error streaming PO pdf:', error);
    res.status(500).json({ message: 'Failed to fetch PO PDF' });
  }
};

export default { getPOs, getPOByNumber, updatePO, uploadPO, streamPOPdf };